# SQLModel Migration Rules

## Core Principles

### 1. SQLModel as Single Source of Truth
- **NEVER** modify database schema directly (via SQL, pgAdmin, etc.)
- **NEVER** create manual Alembic migrations
- **ALWAYS** modify SQLModel models first, then generate migrations
- Database schema must reflect SQLModel models exactly

### 2. Automatic Migration Generation Only
- **ALWAYS** use `alembic revision --autogenerate -m "description"`
- **NEVER** create empty migrations manually
- **NEVER** write custom SQL in migrations without explicit user approval

### 3. Required Import Fix
Alembic autogenerated migrations often miss the `import sqlmodel` statement, which causes runtime errors when applying migrations that use SQLModel types (e.g., `Column(sqlmodel.sql.sqltypes.AutoString())`).

**After generating any migration, ALWAYS:**
1. Read the generated migration file
2. Check if `import sqlmodel` is present
3. If missing, add it to the imports section (usually after `import sqlalchemy as sa`)

## Migration Workflow

### Creating New Models
1. Create SQLModel model class in `backend/app/models/`
2. Import the model in `backend/app/models/__init__.py` if not already
3. Generate migration: `just alembic-auto -m "add {model_name} table"`
4. Read the migration file
5. Add `import sqlmodel` if missing
6. Provide clickable file link and summarize changes for user review
7. Apply migration: `just alembic-up` (only after user confirmation)

### Modifying Existing Models
1. Edit the SQLModel model class
2. Generate migration: `just alembic-auto -m "update {model_name}: {change_description}"`
3. Read the migration file
4. Add `import sqlmodel` if missing
5. Provide clickable file link and summarize changes for user review
6. Apply migration: `just alembic-up` (only after user confirmation)

### Applying Migrations
- **PROVIDE** clickable file link (format: `backend/alembic/versions/{filename}.py:1`)
- **SUMMARIZE** key changes from migration (do not paste full contents)
- **ALWAYS** wait for explicit user confirmation
- Use `just alembic-up` to apply migrations (not direct alembic commands)

## Common SQLModel Types and Their Alembic Representation

### AutoString
- SQLModel: `str = Field()`
- Migration: `sa.Column('field_name', sqlmodel.sql.sqltypes.AutoString(), nullable=False)`
- **Requires**: `import sqlmodel`

### Integer with Default
- SQLModel: `int = Field(default=0)`
- Migration: `sa.Column('field_name', sa.Integer(), nullable=False, server_default='0')`

### Optional Fields
- SQLModel: `Optional[str] = Field(default=None)`
- Migration: `sa.Column('field_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True)`
- **Requires**: `import sqlmodel`

### Foreign Keys
- SQLModel: `user_id: int = Field(foreign_key="users.id")`
- Migration: `sa.Column('user_id', sa.Integer(), sa.ForeignKey('users.id'), nullable=False)`

### Timestamps
- SQLModel: `created_at: datetime = Field(default_factory=datetime.utcnow)`
- Migration: `sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.text('now()'))`

## Import Section Template

Standard import section after autogeneration with fixes:

```python
"""add/update model_name

Revision ID: abc123def456
Revises: previous_revision
Create Date: 2024-01-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel  # ← ALWAYS ADD THIS IF MISSING

# revision identifiers, used by Alembic.
revision = 'abc123def456'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None
```

## Migration Message Conventions

Use clear, descriptive messages:
- ✅ `"add User table with auth fields"`
- ✅ `"update Task: add priority field"`
- ✅ `"add foreign key relationship between Task and User"`
- ❌ `"migration"` (too vague)
- ❌ `"changes"` (too vague)
- ❌ `"update models"` (not specific)

## Safety Checks

### Before Generating Migration
1. Verify PostgreSQL is running: `docker compose ps postgres`
2. Ensure models are properly imported in `backend/app/models/__init__.py`
3. Check for syntax errors: `just typecheck`

### After Generating Migration
1. Read the migration file completely
2. Verify `import sqlmodel` is present
3. Check upgrade() and downgrade() operations match expected changes
4. Look for data loss operations (DROP COLUMN, DROP TABLE) and warn user

### Before Applying Migration
1. Provide clickable file link (format: `backend/alembic/versions/{filename}.py:1`)
2. Summarize key changes and highlight any potentially destructive operations
3. Wait for explicit confirmation
4. Recommend backup if migration modifies data

## Error Handling

### "NameError: name 'sqlmodel' is not defined"
**Cause**: Missing `import sqlmodel` in migration file
**Fix**: Add `import sqlmodel` to imports section

### "Target database is not up to date"
**Cause**: Pending migrations not applied
**Fix**: Run `just alembic-up` before generating new migrations

### "Can't proceed with autogenerate"
**Cause**: Models not imported or PostgreSQL not accessible
**Fix**:
1. Check `backend/app/models/__init__.py`
2. Verify database connection: `docker compose ps postgres`

## Best Practices

1. **One logical change per migration**: Don't bundle unrelated model changes
2. **Test migrations**: Apply to development database first
3. **Review autogenerated code**: Alembic sometimes generates suboptimal migrations
4. **Keep downgrade() working**: Don't leave empty downgrade functions
5. **Document complex migrations**: Add comments for non-obvious operations

## Forbidden Actions Without User Approval

- Creating manual migrations
- Modifying database schema directly
- Editing applied migrations (already in `alembic_version` table)
- Running raw SQL migrations
- Skipping migration validation
- Applying migrations without providing file link and summary to user
- Removing `import sqlmodel` from migrations

## Extending SQLModel with SQLAlchemy

**⚠️ Important: Prefer Native SQLModel Features First**

Before using SQLAlchemy extensions, verify that SQLModel doesn't already support the feature:
- Use `Field(index=True)` for indexes (not `sa_column=Column(..., index=True)`)
- Use `Field(foreign_key="table.id")` for foreign keys (not SQLAlchemy ForeignKey)
- Use `Field(default=value)` for defaults when possible
- Use `Relationship()` for relationships (not SQLAlchemy relationship)

**Only extend with SQLAlchemy when SQLModel truly lacks support** (e.g., PostgreSQL-specific types, CHECK constraints, composite constraints).

When SQLModel doesn't natively support a feature, extend it using SQLAlchemy constructs via `sa_column` parameter in `Field()`.

### Using sa_column for Advanced Column Types

```python
from sqlmodel import Field, SQLModel, Column
from sqlalchemy import JSON, ARRAY, String, CheckConstraint, text
from typing import Optional

class Example(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)

    # PostgreSQL JSON column
    metadata_json: dict = Field(
        sa_column=Column(JSON, nullable=False, server_default=text("'{}'"))
    )

    # PostgreSQL ARRAY column
    tags: list = Field(
        sa_column=Column(ARRAY(String), nullable=True)
    )

    # Column with CHECK constraint
    rating: int = Field(
        sa_column=Column(
            Integer,
            CheckConstraint('rating >= 1 AND rating <= 5'),
            nullable=False
        )
    )

    # Text column with specific server default
    status: str = Field(
        sa_column=Column(String, server_default='pending', nullable=False)
    )
```

### Common Use Cases

**PostgreSQL-specific types:**
```python
from sqlalchemy.dialects.postgresql import UUID, JSONB, ARRAY

# UUID primary key
id: str = Field(sa_column=Column(UUID(as_uuid=True), primary_key=True))

# JSONB for better indexing
config: dict = Field(sa_column=Column(JSONB, nullable=False))
```

**Database constraints:**
```python
from sqlalchemy import UniqueConstraint

# Composite unique constraint (add to model's __table_args__)
class User(SQLModel, table=True):
    email: str = Field()
    tenant_id: int = Field()

    __table_args__ = (
        UniqueConstraint('email', 'tenant_id', name='unique_email_per_tenant'),
    )
```

**Server-side defaults:**
```python
# Auto-generated UUID
from sqlalchemy import text

id: str = Field(
    sa_column=Column(String, server_default=text("gen_random_uuid()"), primary_key=True)
)
```

### Migration Impact

When using `sa_column`, migrations will include raw SQLAlchemy column definitions:

```python
# Migration for JSON column
op.add_column('example',
    sa.Column('metadata_json', sa.JSON(), server_default=sa.text("'{}'"), nullable=False)
)

# Migration for ARRAY column
op.add_column('example',
    sa.Column('tags', sa.ARRAY(sa.String()), nullable=True)
)
```

**ALWAYS** verify `import sqlalchemy as sa` is present when using advanced column types.