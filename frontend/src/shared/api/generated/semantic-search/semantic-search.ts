/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Pulse Radar API
 * Feel the heartbeat of your projects
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AppApiV1SemanticSearchMessageSearchResult,
  AppApiV1SemanticSearchTopicSearchResult,
  AtomSearchResult,
  FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams,
  FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams,
  FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams,
  HTTPValidationError,
  SearchAtomsSemanticApiV1SearchAtomsGetParams,
  SearchMessagesSemanticApiV1SearchMessagesGetParams,
  SearchTopicsSemanticApiV1SearchTopicsGetParams
} from '../../model';

import { customInstance } from '../../../lib/api/mutator';




/**
 * Search messages using semantic similarity to find relevant content.

Uses vector embeddings to find messages that are semantically similar to the
query text, even if they don't contain the exact words. Results are ranked
by similarity score.

Example:
    GET /api/v1/search/messages?query=bug+in+production&provider_id=550e8400-e29b-41d4-a716-446655440000&limit=10&threshold=0.7

Args:
    query: Natural language search query
    provider_id: UUID of LLM provider to use for embedding generation
    limit: Maximum results to return (1-100)
    threshold: Minimum similarity score (0.0-1.0)

Returns:
    List of messages with similarity scores, ordered by relevance
 * @summary Search messages by semantic similarity
 */
export const searchMessagesSemanticApiV1SearchMessagesGet = (
    params: SearchMessagesSemanticApiV1SearchMessagesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AppApiV1SemanticSearchMessageSearchResult[]>(
      {url: `/api/v1/search/messages`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSearchMessagesSemanticApiV1SearchMessagesGetQueryKey = (params?: SearchMessagesSemanticApiV1SearchMessagesGetParams,) => {
    return [
    `/api/v1/search/messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchMessagesSemanticApiV1SearchMessagesGetQueryOptions = <TData = Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError = HTTPValidationError>(params: SearchMessagesSemanticApiV1SearchMessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMessagesSemanticApiV1SearchMessagesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>> = ({ signal }) => searchMessagesSemanticApiV1SearchMessagesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchMessagesSemanticApiV1SearchMessagesGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>>
export type SearchMessagesSemanticApiV1SearchMessagesGetQueryError = HTTPValidationError


export function useSearchMessagesSemanticApiV1SearchMessagesGet<TData = Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError = HTTPValidationError>(
 params: SearchMessagesSemanticApiV1SearchMessagesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>,
          TError,
          Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchMessagesSemanticApiV1SearchMessagesGet<TData = Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError = HTTPValidationError>(
 params: SearchMessagesSemanticApiV1SearchMessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>,
          TError,
          Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchMessagesSemanticApiV1SearchMessagesGet<TData = Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError = HTTPValidationError>(
 params: SearchMessagesSemanticApiV1SearchMessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search messages by semantic similarity
 */

export function useSearchMessagesSemanticApiV1SearchMessagesGet<TData = Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError = HTTPValidationError>(
 params: SearchMessagesSemanticApiV1SearchMessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchMessagesSemanticApiV1SearchMessagesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchMessagesSemanticApiV1SearchMessagesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Find messages similar to a specific message using its embedding.

Uses the message's existing vector embedding to find other semantically
similar messages. Useful for exploring related content or finding
conversations on similar topics.

Example:
    GET /api/v1/search/messages/123/similar?limit=5&threshold=0.8

Args:
    message_id: ID of the reference message
    limit: Maximum results to return (1-100)
    threshold: Minimum similarity score (0.0-1.0)

Returns:
    List of similar messages with similarity scores, ordered by relevance
 * @summary Find messages similar to a given message
 */
export const findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet = (
    messageId: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AppApiV1SemanticSearchMessageSearchResult[]>(
      {url: `/api/v1/search/messages/${messageId}/similar`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryKey = (messageId?: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams,) => {
    return [
    `/api/v1/search/messages/${messageId}/similar`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryOptions = <TData = Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError = HTTPValidationError>(messageId: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryKey(messageId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>> = ({ signal }) => findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet(messageId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(messageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryResult = NonNullable<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>>
export type FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryError = HTTPValidationError


export function useFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError = HTTPValidationError>(
 messageId: number,
    params: undefined |  FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>,
          TError,
          Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>,
          TError,
          Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Find messages similar to a given message
 */

export function useFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarMessagesApiV1SearchMessagesMessageIdSimilarGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindSimilarMessagesApiV1SearchMessagesMessageIdSimilarGetQueryOptions(messageId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Find potential duplicate messages with very high similarity.

Uses a high similarity threshold (default 0.95) to detect near-duplicate
content. Useful for deduplication, spam detection, or finding repeated messages.

Example:
    GET /api/v1/search/messages/123/duplicates?threshold=0.95

Args:
    message_id: ID of the reference message
    threshold: High similarity threshold (0.0-1.0, default 0.95)

Returns:
    List of potential duplicate messages with similarity scores
 * @summary Find potential duplicate messages
 */
export const findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet = (
    messageId: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AppApiV1SemanticSearchMessageSearchResult[]>(
      {url: `/api/v1/search/messages/${messageId}/duplicates`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryKey = (messageId?: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams,) => {
    return [
    `/api/v1/search/messages/${messageId}/duplicates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryOptions = <TData = Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError = HTTPValidationError>(messageId: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryKey(messageId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>> = ({ signal }) => findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet(messageId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(messageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryResult = NonNullable<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>>
export type FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryError = HTTPValidationError


export function useFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet<TData = Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError = HTTPValidationError>(
 messageId: number,
    params: undefined |  FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>,
          TError,
          Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet<TData = Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>,
          TError,
          Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet<TData = Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Find potential duplicate messages
 */

export function useFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet<TData = Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError = HTTPValidationError>(
 messageId: number,
    params?: FindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindDuplicateMessagesApiV1SearchMessagesMessageIdDuplicatesGetQueryOptions(messageId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Search atoms using semantic similarity to find relevant knowledge units.

Uses vector embeddings to find atoms (atomic knowledge units) that are
semantically similar to the query. Searches across both atom titles and
content. Results are ranked by similarity score.

Example:
    GET /api/v1/search/atoms?query=dependency+injection&provider_id=550e8400-e29b-41d4-a716-446655440000&limit=10&threshold=0.7

Args:
    query: Natural language search query
    provider_id: UUID of LLM provider to use for embedding generation
    limit: Maximum results to return (1-100)
    threshold: Minimum similarity score (0.0-1.0)

Returns:
    List of atoms with similarity scores, ordered by relevance
 * @summary Search atoms by semantic similarity
 */
export const searchAtomsSemanticApiV1SearchAtomsGet = (
    params: SearchAtomsSemanticApiV1SearchAtomsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AtomSearchResult[]>(
      {url: `/api/v1/search/atoms`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSearchAtomsSemanticApiV1SearchAtomsGetQueryKey = (params?: SearchAtomsSemanticApiV1SearchAtomsGetParams,) => {
    return [
    `/api/v1/search/atoms`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchAtomsSemanticApiV1SearchAtomsGetQueryOptions = <TData = Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError = HTTPValidationError>(params: SearchAtomsSemanticApiV1SearchAtomsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAtomsSemanticApiV1SearchAtomsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>> = ({ signal }) => searchAtomsSemanticApiV1SearchAtomsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchAtomsSemanticApiV1SearchAtomsGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>>
export type SearchAtomsSemanticApiV1SearchAtomsGetQueryError = HTTPValidationError


export function useSearchAtomsSemanticApiV1SearchAtomsGet<TData = Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError = HTTPValidationError>(
 params: SearchAtomsSemanticApiV1SearchAtomsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>,
          TError,
          Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAtomsSemanticApiV1SearchAtomsGet<TData = Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError = HTTPValidationError>(
 params: SearchAtomsSemanticApiV1SearchAtomsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>,
          TError,
          Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAtomsSemanticApiV1SearchAtomsGet<TData = Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError = HTTPValidationError>(
 params: SearchAtomsSemanticApiV1SearchAtomsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search atoms by semantic similarity
 */

export function useSearchAtomsSemanticApiV1SearchAtomsGet<TData = Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError = HTTPValidationError>(
 params: SearchAtomsSemanticApiV1SearchAtomsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAtomsSemanticApiV1SearchAtomsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchAtomsSemanticApiV1SearchAtomsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Find atoms similar to a specific atom using its embedding.

Uses the atom's existing vector embedding to find other semantically
similar knowledge units. Useful for exploring related concepts or
discovering connections in the knowledge graph.

Example:
    GET /api/v1/search/atoms/42/similar?limit=5&threshold=0.8

Args:
    atom_id: ID of the reference atom
    limit: Maximum results to return (1-100)
    threshold: Minimum similarity score (0.0-1.0)

Returns:
    List of similar atoms with similarity scores, ordered by relevance
 * @summary Find atoms similar to a given atom
 */
export const findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet = (
    atomId: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AtomSearchResult[]>(
      {url: `/api/v1/search/atoms/${atomId}/similar`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryKey = (atomId?: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams,) => {
    return [
    `/api/v1/search/atoms/${atomId}/similar`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryOptions = <TData = Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError = HTTPValidationError>(atomId: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryKey(atomId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>> = ({ signal }) => findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet(atomId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(atomId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryResult = NonNullable<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>>
export type FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryError = HTTPValidationError


export function useFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError = HTTPValidationError>(
 atomId: number,
    params: undefined |  FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>,
          TError,
          Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError = HTTPValidationError>(
 atomId: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>,
          TError,
          Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError = HTTPValidationError>(
 atomId: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Find atoms similar to a given atom
 */

export function useFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet<TData = Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError = HTTPValidationError>(
 atomId: number,
    params?: FindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findSimilarAtomsApiV1SearchAtomsAtomIdSimilarGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindSimilarAtomsApiV1SearchAtomsAtomIdSimilarGetQueryOptions(atomId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Search topics using semantic similarity to find relevant categories.

Uses vector embeddings to find topics that are semantically similar to the
query text. Searches across both topic names and descriptions. Results are
ranked by similarity score.

Example:
    GET /api/v1/search/topics?query=mobile+development&provider_id=550e8400-e29b-41d4-a716-446655440000&limit=10&threshold=0.7

Args:
    query: Natural language search query
    provider_id: UUID of LLM provider to use for embedding generation
    limit: Maximum results to return (1-100)
    threshold: Minimum similarity score (0.0-1.0)

Returns:
    List of topics with similarity scores, ordered by relevance
 * @summary Search topics by semantic similarity
 */
export const searchTopicsSemanticApiV1SearchTopicsGet = (
    params: SearchTopicsSemanticApiV1SearchTopicsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AppApiV1SemanticSearchTopicSearchResult[]>(
      {url: `/api/v1/search/topics`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSearchTopicsSemanticApiV1SearchTopicsGetQueryKey = (params?: SearchTopicsSemanticApiV1SearchTopicsGetParams,) => {
    return [
    `/api/v1/search/topics`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchTopicsSemanticApiV1SearchTopicsGetQueryOptions = <TData = Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError = HTTPValidationError>(params: SearchTopicsSemanticApiV1SearchTopicsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchTopicsSemanticApiV1SearchTopicsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>> = ({ signal }) => searchTopicsSemanticApiV1SearchTopicsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchTopicsSemanticApiV1SearchTopicsGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>>
export type SearchTopicsSemanticApiV1SearchTopicsGetQueryError = HTTPValidationError


export function useSearchTopicsSemanticApiV1SearchTopicsGet<TData = Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError = HTTPValidationError>(
 params: SearchTopicsSemanticApiV1SearchTopicsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>,
          TError,
          Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchTopicsSemanticApiV1SearchTopicsGet<TData = Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError = HTTPValidationError>(
 params: SearchTopicsSemanticApiV1SearchTopicsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>,
          TError,
          Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchTopicsSemanticApiV1SearchTopicsGet<TData = Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError = HTTPValidationError>(
 params: SearchTopicsSemanticApiV1SearchTopicsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search topics by semantic similarity
 */

export function useSearchTopicsSemanticApiV1SearchTopicsGet<TData = Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError = HTTPValidationError>(
 params: SearchTopicsSemanticApiV1SearchTopicsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchTopicsSemanticApiV1SearchTopicsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchTopicsSemanticApiV1SearchTopicsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



