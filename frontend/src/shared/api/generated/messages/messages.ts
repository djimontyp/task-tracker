/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Pulse Radar API
 * Feel the heartbeat of your projects
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApproveMessageClassificationApiV1MessagesMessageIdApprovePost200,
  CreateMessageApiV1MessagesPost201,
  GetMessagesApiV1MessagesGetParams,
  HTTPValidationError,
  MessageCreateRequest,
  MessageFiltersResponse,
  MessageInspectResponse,
  MessageResponse,
  PaginatedMessagesResponse,
  ReassignMessageTopicApiV1MessagesMessageIdReassignPut200,
  ReassignRequest,
  RejectMessageClassificationApiV1MessagesMessageIdRejectPost200,
  RejectRequest
} from '../../model';

import { customInstance } from '../../../lib/api/mutator';




/**
 * Create a new message.

Requires author_id (User.id) and source_id.
Broadcasts created message to WebSocket clients in real-time.
 * @summary Create a new message
 */
export const createMessageApiV1MessagesPost = (
    messageCreateRequest: MessageCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CreateMessageApiV1MessagesPost201>(
      {url: `/api/v1/messages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: messageCreateRequest, signal
    },
      );
    }
  


export const getCreateMessageApiV1MessagesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>, TError,{data: MessageCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>, TError,{data: MessageCreateRequest}, TContext> => {

const mutationKey = ['createMessageApiV1MessagesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>, {data: MessageCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createMessageApiV1MessagesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMessageApiV1MessagesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>>
    export type CreateMessageApiV1MessagesPostMutationBody = MessageCreateRequest
    export type CreateMessageApiV1MessagesPostMutationError = HTTPValidationError

    /**
 * @summary Create a new message
 */
export const useCreateMessageApiV1MessagesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>, TError,{data: MessageCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createMessageApiV1MessagesPost>>,
        TError,
        {data: MessageCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateMessageApiV1MessagesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve messages with pagination and optional filtering.

Supports filtering by author, source, topic, date range, and noise classification.
Importance score filtering allows finding high-signal messages (>0.7) or noise (<0.3).
Returns most recent messages first with pagination support.
 * @summary Get messages list with pagination
 */
export const getMessagesApiV1MessagesGet = (
    params?: GetMessagesApiV1MessagesGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedMessagesResponse>(
      {url: `/api/v1/messages`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetMessagesApiV1MessagesGetQueryKey = (params?: GetMessagesApiV1MessagesGetParams,) => {
    return [
    `/api/v1/messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMessagesApiV1MessagesGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError = HTTPValidationError>(params?: GetMessagesApiV1MessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessagesApiV1MessagesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>> = ({ signal }) => getMessagesApiV1MessagesGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessagesApiV1MessagesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>>
export type GetMessagesApiV1MessagesGetQueryError = HTTPValidationError


export function useGetMessagesApiV1MessagesGet<TData = Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError = HTTPValidationError>(
 params: undefined |  GetMessagesApiV1MessagesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>,
          TError,
          Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessagesApiV1MessagesGet<TData = Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError = HTTPValidationError>(
 params?: GetMessagesApiV1MessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>,
          TError,
          Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessagesApiV1MessagesGet<TData = Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError = HTTPValidationError>(
 params?: GetMessagesApiV1MessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get messages list with pagination
 */

export function useGetMessagesApiV1MessagesGet<TData = Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError = HTTPValidationError>(
 params?: GetMessagesApiV1MessagesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessagesApiV1MessagesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessagesApiV1MessagesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get available filter options for messages.

Returns unique authors, sources, date range, and total message count
for building filter UI components.
 * @summary Get message filter options
 */
export const getMessageFiltersApiV1MessagesFiltersGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageFiltersResponse>(
      {url: `/api/v1/messages/filters`, method: 'GET', signal
    },
      );
    }
  



export const getGetMessageFiltersApiV1MessagesFiltersGetQueryKey = () => {
    return [
    `/api/v1/messages/filters`
    ] as const;
    }

    
export const getGetMessageFiltersApiV1MessagesFiltersGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageFiltersApiV1MessagesFiltersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>> = ({ signal }) => getMessageFiltersApiV1MessagesFiltersGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageFiltersApiV1MessagesFiltersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>>
export type GetMessageFiltersApiV1MessagesFiltersGetQueryError = unknown


export function useGetMessageFiltersApiV1MessagesFiltersGet<TData = Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageFiltersApiV1MessagesFiltersGet<TData = Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageFiltersApiV1MessagesFiltersGet<TData = Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get message filter options
 */

export function useGetMessageFiltersApiV1MessagesFiltersGet<TData = Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageFiltersApiV1MessagesFiltersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageFiltersApiV1MessagesFiltersGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get message details for consumer view.

Returns basic message information with author, source, and topic details
for displaying in ConsumerMessageModal.
 * @summary Get message details
 */
export const getMessageDetailsApiV1MessagesMessageIdGet = (
    messageId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/api/v1/messages/${messageId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetMessageDetailsApiV1MessagesMessageIdGetQueryKey = (messageId?: string,) => {
    return [
    `/api/v1/messages/${messageId}`
    ] as const;
    }

    
export const getGetMessageDetailsApiV1MessagesMessageIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError = HTTPValidationError>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageDetailsApiV1MessagesMessageIdGetQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>> = ({ signal }) => getMessageDetailsApiV1MessagesMessageIdGet(messageId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(messageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageDetailsApiV1MessagesMessageIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>>
export type GetMessageDetailsApiV1MessagesMessageIdGetQueryError = HTTPValidationError


export function useGetMessageDetailsApiV1MessagesMessageIdGet<TData = Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError = HTTPValidationError>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageDetailsApiV1MessagesMessageIdGet<TData = Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageDetailsApiV1MessagesMessageIdGet<TData = Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get message details
 */

export function useGetMessageDetailsApiV1MessagesMessageIdGet<TData = Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageDetailsApiV1MessagesMessageIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageDetailsApiV1MessagesMessageIdGetQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get full inspection details for a message.

Returns comprehensive data for MessageInspectModal:
- Message metadata (content, source, timestamp)
- Classification details (confidence, reasoning, topic)
- Extracted atoms (entities, keywords, embeddings)
- Classification history (reassignments, approvals)
 * @summary Get full message inspection details
 */
export const inspectMessageApiV1MessagesMessageIdInspectGet = (
    messageId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageInspectResponse>(
      {url: `/api/v1/messages/${messageId}/inspect`, method: 'GET', signal
    },
      );
    }
  



export const getInspectMessageApiV1MessagesMessageIdInspectGetQueryKey = (messageId?: string,) => {
    return [
    `/api/v1/messages/${messageId}/inspect`
    ] as const;
    }

    
export const getInspectMessageApiV1MessagesMessageIdInspectGetQueryOptions = <TData = Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError = HTTPValidationError>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInspectMessageApiV1MessagesMessageIdInspectGetQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>> = ({ signal }) => inspectMessageApiV1MessagesMessageIdInspectGet(messageId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(messageId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InspectMessageApiV1MessagesMessageIdInspectGetQueryResult = NonNullable<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>>
export type InspectMessageApiV1MessagesMessageIdInspectGetQueryError = HTTPValidationError


export function useInspectMessageApiV1MessagesMessageIdInspectGet<TData = Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError = HTTPValidationError>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>,
          TError,
          Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspectMessageApiV1MessagesMessageIdInspectGet<TData = Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>,
          TError,
          Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInspectMessageApiV1MessagesMessageIdInspectGet<TData = Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get full message inspection details
 */

export function useInspectMessageApiV1MessagesMessageIdInspectGet<TData = Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError = HTTPValidationError>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof inspectMessageApiV1MessagesMessageIdInspectGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInspectMessageApiV1MessagesMessageIdInspectGetQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Reassign message to a different topic.

Steps:
1. Validate message exists
2. Validate new topic exists
3. Update message.topic_id
4. Log history event (reassignment)
5. Broadcast WebSocket update
6. Return updated message
 * @summary Reassign message to different topic
 */
export const reassignMessageTopicApiV1MessagesMessageIdReassignPut = (
    messageId: string,
    reassignRequest: ReassignRequest,
 ) => {
      
      
      return customInstance<ReassignMessageTopicApiV1MessagesMessageIdReassignPut200>(
      {url: `/api/v1/messages/${messageId}/reassign`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: reassignRequest
    },
      );
    }
  


export const getReassignMessageTopicApiV1MessagesMessageIdReassignPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>, TError,{messageId: string;data: ReassignRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>, TError,{messageId: string;data: ReassignRequest}, TContext> => {

const mutationKey = ['reassignMessageTopicApiV1MessagesMessageIdReassignPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>, {messageId: string;data: ReassignRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  reassignMessageTopicApiV1MessagesMessageIdReassignPut(messageId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReassignMessageTopicApiV1MessagesMessageIdReassignPutMutationResult = NonNullable<Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>>
    export type ReassignMessageTopicApiV1MessagesMessageIdReassignPutMutationBody = ReassignRequest
    export type ReassignMessageTopicApiV1MessagesMessageIdReassignPutMutationError = HTTPValidationError

    /**
 * @summary Reassign message to different topic
 */
export const useReassignMessageTopicApiV1MessagesMessageIdReassignPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>, TError,{messageId: string;data: ReassignRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reassignMessageTopicApiV1MessagesMessageIdReassignPut>>,
        TError,
        {messageId: string;data: ReassignRequest},
        TContext
      > => {

      const mutationOptions = getReassignMessageTopicApiV1MessagesMessageIdReassignPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Approve message classification as correct.

Steps:
1. Update message.status = "approved"
2. Log history event
3. Store feedback for model retraining
4. Broadcast WebSocket update
 * @summary Approve message classification
 */
export const approveMessageClassificationApiV1MessagesMessageIdApprovePost = (
    messageId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApproveMessageClassificationApiV1MessagesMessageIdApprovePost200>(
      {url: `/api/v1/messages/${messageId}/approve`, method: 'POST', signal
    },
      );
    }
  


export const getApproveMessageClassificationApiV1MessagesMessageIdApprovePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>, TError,{messageId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>, TError,{messageId: string}, TContext> => {

const mutationKey = ['approveMessageClassificationApiV1MessagesMessageIdApprovePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>, {messageId: string}> = (props) => {
          const {messageId} = props ?? {};

          return  approveMessageClassificationApiV1MessagesMessageIdApprovePost(messageId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApproveMessageClassificationApiV1MessagesMessageIdApprovePostMutationResult = NonNullable<Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>>
    
    export type ApproveMessageClassificationApiV1MessagesMessageIdApprovePostMutationError = HTTPValidationError

    /**
 * @summary Approve message classification
 */
export const useApproveMessageClassificationApiV1MessagesMessageIdApprovePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>, TError,{messageId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof approveMessageClassificationApiV1MessagesMessageIdApprovePost>>,
        TError,
        {messageId: string},
        TContext
      > => {

      const mutationOptions = getApproveMessageClassificationApiV1MessagesMessageIdApprovePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Reject message classification as incorrect.

Steps:
1. Update message.status = "rejected"
2. Store rejection reason
3. Log history event
4. Store feedback for model retraining (negative sample)
5. Broadcast WebSocket update
 * @summary Reject message classification
 */
export const rejectMessageClassificationApiV1MessagesMessageIdRejectPost = (
    messageId: string,
    rejectRequest: RejectRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<RejectMessageClassificationApiV1MessagesMessageIdRejectPost200>(
      {url: `/api/v1/messages/${messageId}/reject`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rejectRequest, signal
    },
      );
    }
  


export const getRejectMessageClassificationApiV1MessagesMessageIdRejectPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>, TError,{messageId: string;data: RejectRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>, TError,{messageId: string;data: RejectRequest}, TContext> => {

const mutationKey = ['rejectMessageClassificationApiV1MessagesMessageIdRejectPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>, {messageId: string;data: RejectRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  rejectMessageClassificationApiV1MessagesMessageIdRejectPost(messageId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RejectMessageClassificationApiV1MessagesMessageIdRejectPostMutationResult = NonNullable<Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>>
    export type RejectMessageClassificationApiV1MessagesMessageIdRejectPostMutationBody = RejectRequest
    export type RejectMessageClassificationApiV1MessagesMessageIdRejectPostMutationError = HTTPValidationError

    /**
 * @summary Reject message classification
 */
export const useRejectMessageClassificationApiV1MessagesMessageIdRejectPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>, TError,{messageId: string;data: RejectRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rejectMessageClassificationApiV1MessagesMessageIdRejectPost>>,
        TError,
        {messageId: string;data: RejectRequest},
        TContext
      > => {

      const mutationOptions = getRejectMessageClassificationApiV1MessagesMessageIdRejectPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    