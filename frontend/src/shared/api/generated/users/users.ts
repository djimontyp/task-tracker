/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Pulse Radar API
 * Feel the heartbeat of your projects
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  LinkTelegramProfileRequest,
  TelegramProfileResponse,
  UserCreateRequest,
  UserResponse
} from '../../model';

import { customInstance } from '../../../lib/api/mutator';




/**
 * Retrieve all users.

Returns complete user information including computed full_name.
 * @summary Get all users
 */
export const getUsersApiV1UsersGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponse[]>(
      {url: `/api/v1/users`, method: 'GET', signal
    },
      );
    }
  



export const getGetUsersApiV1UsersGetQueryKey = () => {
    return [
    `/api/v1/users`
    ] as const;
    }

    
export const getGetUsersApiV1UsersGetQueryOptions = <TData = Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersApiV1UsersGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>> = ({ signal }) => getUsersApiV1UsersGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersApiV1UsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>>
export type GetUsersApiV1UsersGetQueryError = unknown


export function useGetUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiV1UsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiV1UsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersApiV1UsersGet>>,
          TError,
          Awaited<ReturnType<typeof getUsersApiV1UsersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all users
 */

export function useGetUsersApiV1UsersGet<TData = Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersApiV1UsersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersApiV1UsersGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new user manually.

Used for manual user creation (not via Telegram auto-linking).
 * @summary Create new user
 */
export const createUserApiV1UsersPost = (
    userCreateRequest: UserCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponse>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreateRequest, signal
    },
      );
    }
  


export const getCreateUserApiV1UsersPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreateRequest}, TContext> => {

const mutationKey = ['createUserApiV1UsersPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, {data: UserCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUserApiV1UsersPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserApiV1UsersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createUserApiV1UsersPost>>>
    export type CreateUserApiV1UsersPostMutationBody = UserCreateRequest
    export type CreateUserApiV1UsersPostMutationError = HTTPValidationError

    /**
 * @summary Create new user
 */
export const useCreateUserApiV1UsersPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserApiV1UsersPost>>, TError,{data: UserCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUserApiV1UsersPost>>,
        TError,
        {data: UserCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateUserApiV1UsersPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve a specific user by ID.

Raises 404 error if user doesn't exist.
 * @summary Get user by ID
 */
export const getUserApiV1UsersUserIdGet = (
    userId: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponse>(
      {url: `/api/v1/users/${userId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserApiV1UsersUserIdGetQueryKey = (userId?: number,) => {
    return [
    `/api/v1/users/${userId}`
    ] as const;
    }

    
export const getGetUserApiV1UsersUserIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError = void | HTTPValidationError>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserApiV1UsersUserIdGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>> = ({ signal }) => getUserApiV1UsersUserIdGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserApiV1UsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>>
export type GetUserApiV1UsersUserIdGetQueryError = void | HTTPValidationError


export function useGetUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>,
          TError,
          Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user by ID
 */

export function useGetUserApiV1UsersUserIdGet<TData = Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserApiV1UsersUserIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserApiV1UsersUserIdGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve Telegram profile for a user.

Returns 404 if user doesn't exist or doesn't have a Telegram profile.
 * @summary Get user's Telegram profile
 */
export const getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet = (
    userId: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TelegramProfileResponse>(
      {url: `/api/v1/users/${userId}/telegram-profile`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryKey = (userId?: number,) => {
    return [
    `/api/v1/users/${userId}/telegram-profile`
    ] as const;
    }

    
export const getGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError = void | HTTPValidationError>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>> = ({ signal }) => getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>>
export type GetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryError = void | HTTPValidationError


export function useGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGet<TData = Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError = void | HTTPValidationError>(
 userId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>,
          TError,
          Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGet<TData = Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>,
          TError,
          Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGet<TData = Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user's Telegram profile
 */

export function useGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGet<TData = Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError = void | HTTPValidationError>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserTelegramProfileApiV1UsersUserIdTelegramProfileGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserTelegramProfileApiV1UsersUserIdTelegramProfileGetQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Manually link an existing Telegram user to a User.

This is used when auto-linking fails or for manual correction.
Requires that telegram_user_id exists in system (user must have sent at least one message).
 * @summary Manually link Telegram profile to user
 */
export const linkTelegramProfileApiV1UsersUserIdLinkTelegramPost = (
    userId: number,
    linkTelegramProfileRequest: LinkTelegramProfileRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TelegramProfileResponse>(
      {url: `/api/v1/users/${userId}/link-telegram`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: linkTelegramProfileRequest, signal
    },
      );
    }
  


export const getLinkTelegramProfileApiV1UsersUserIdLinkTelegramPostMutationOptions = <TError = void | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>, TError,{userId: number;data: LinkTelegramProfileRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>, TError,{userId: number;data: LinkTelegramProfileRequest}, TContext> => {

const mutationKey = ['linkTelegramProfileApiV1UsersUserIdLinkTelegramPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>, {userId: number;data: LinkTelegramProfileRequest}> = (props) => {
          const {userId,data} = props ?? {};

          return  linkTelegramProfileApiV1UsersUserIdLinkTelegramPost(userId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LinkTelegramProfileApiV1UsersUserIdLinkTelegramPostMutationResult = NonNullable<Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>>
    export type LinkTelegramProfileApiV1UsersUserIdLinkTelegramPostMutationBody = LinkTelegramProfileRequest
    export type LinkTelegramProfileApiV1UsersUserIdLinkTelegramPostMutationError = void | void | HTTPValidationError

    /**
 * @summary Manually link Telegram profile to user
 */
export const useLinkTelegramProfileApiV1UsersUserIdLinkTelegramPost = <TError = void | void | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>, TError,{userId: number;data: LinkTelegramProfileRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof linkTelegramProfileApiV1UsersUserIdLinkTelegramPost>>,
        TError,
        {userId: number;data: LinkTelegramProfileRequest},
        TContext
      > => {

      const mutationOptions = getLinkTelegramProfileApiV1UsersUserIdLinkTelegramPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    