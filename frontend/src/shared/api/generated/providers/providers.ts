/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Pulse Radar API
 * Feel the heartbeat of your projects
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  LLMProviderCreate,
  LLMProviderPublic,
  LLMProviderUpdate,
  ListOllamaModelsApiV1ProvidersOllamaModelsGetParams,
  ListProvidersApiV1ProvidersGetParams,
  OllamaModelsResponse
} from '../../model';

import { customInstance } from '../../../lib/api/mutator';




/**
 * Create new LLM provider with encrypted credentials. Triggers async validation.
 * @summary Create LLM provider
 */
export const createProviderApiV1ProvidersPost = (
    lLMProviderCreate: LLMProviderCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<LLMProviderPublic>(
      {url: `/api/v1/providers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: lLMProviderCreate, signal
    },
      );
    }
  


export const getCreateProviderApiV1ProvidersPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>, TError,{data: LLMProviderCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>, TError,{data: LLMProviderCreate}, TContext> => {

const mutationKey = ['createProviderApiV1ProvidersPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>, {data: LLMProviderCreate}> = (props) => {
          const {data} = props ?? {};

          return  createProviderApiV1ProvidersPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProviderApiV1ProvidersPostMutationResult = NonNullable<Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>>
    export type CreateProviderApiV1ProvidersPostMutationBody = LLMProviderCreate
    export type CreateProviderApiV1ProvidersPostMutationError = HTTPValidationError

    /**
 * @summary Create LLM provider
 */
export const useCreateProviderApiV1ProvidersPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>, TError,{data: LLMProviderCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProviderApiV1ProvidersPost>>,
        TError,
        {data: LLMProviderCreate},
        TContext
      > => {

      const mutationOptions = getCreateProviderApiV1ProvidersPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get list of all configured LLM providers with pagination and filters.
 * @summary List all providers
 */
export const listProvidersApiV1ProvidersGet = (
    params?: ListProvidersApiV1ProvidersGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<LLMProviderPublic[]>(
      {url: `/api/v1/providers`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListProvidersApiV1ProvidersGetQueryKey = (params?: ListProvidersApiV1ProvidersGetParams,) => {
    return [
    `/api/v1/providers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListProvidersApiV1ProvidersGetQueryOptions = <TData = Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError = HTTPValidationError>(params?: ListProvidersApiV1ProvidersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListProvidersApiV1ProvidersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>> = ({ signal }) => listProvidersApiV1ProvidersGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListProvidersApiV1ProvidersGetQueryResult = NonNullable<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>>
export type ListProvidersApiV1ProvidersGetQueryError = HTTPValidationError


export function useListProvidersApiV1ProvidersGet<TData = Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError = HTTPValidationError>(
 params: undefined |  ListProvidersApiV1ProvidersGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>,
          TError,
          Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListProvidersApiV1ProvidersGet<TData = Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError = HTTPValidationError>(
 params?: ListProvidersApiV1ProvidersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>,
          TError,
          Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListProvidersApiV1ProvidersGet<TData = Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError = HTTPValidationError>(
 params?: ListProvidersApiV1ProvidersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all providers
 */

export function useListProvidersApiV1ProvidersGet<TData = Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError = HTTPValidationError>(
 params?: ListProvidersApiV1ProvidersGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listProvidersApiV1ProvidersGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListProvidersApiV1ProvidersGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get single provider configuration with validation details.
 * @summary Get provider by ID
 */
export const getProviderApiV1ProvidersProviderIdGet = (
    providerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<LLMProviderPublic>(
      {url: `/api/v1/providers/${providerId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetProviderApiV1ProvidersProviderIdGetQueryKey = (providerId?: string,) => {
    return [
    `/api/v1/providers/${providerId}`
    ] as const;
    }

    
export const getGetProviderApiV1ProvidersProviderIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError = HTTPValidationError>(providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProviderApiV1ProvidersProviderIdGetQueryKey(providerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>> = ({ signal }) => getProviderApiV1ProvidersProviderIdGet(providerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(providerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProviderApiV1ProvidersProviderIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>>
export type GetProviderApiV1ProvidersProviderIdGetQueryError = HTTPValidationError


export function useGetProviderApiV1ProvidersProviderIdGet<TData = Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError = HTTPValidationError>(
 providerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>,
          TError,
          Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProviderApiV1ProvidersProviderIdGet<TData = Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>,
          TError,
          Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProviderApiV1ProvidersProviderIdGet<TData = Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get provider by ID
 */

export function useGetProviderApiV1ProvidersProviderIdGet<TData = Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProviderApiV1ProvidersProviderIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProviderApiV1ProvidersProviderIdGetQueryOptions(providerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update provider configuration. Triggers re-validation if connection details changed.
 * @summary Update provider
 */
export const updateProviderApiV1ProvidersProviderIdPut = (
    providerId: string,
    lLMProviderUpdate: LLMProviderUpdate,
 ) => {
      
      
      return customInstance<LLMProviderPublic>(
      {url: `/api/v1/providers/${providerId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: lLMProviderUpdate
    },
      );
    }
  


export const getUpdateProviderApiV1ProvidersProviderIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>, TError,{providerId: string;data: LLMProviderUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>, TError,{providerId: string;data: LLMProviderUpdate}, TContext> => {

const mutationKey = ['updateProviderApiV1ProvidersProviderIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>, {providerId: string;data: LLMProviderUpdate}> = (props) => {
          const {providerId,data} = props ?? {};

          return  updateProviderApiV1ProvidersProviderIdPut(providerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProviderApiV1ProvidersProviderIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>>
    export type UpdateProviderApiV1ProvidersProviderIdPutMutationBody = LLMProviderUpdate
    export type UpdateProviderApiV1ProvidersProviderIdPutMutationError = HTTPValidationError

    /**
 * @summary Update provider
 */
export const useUpdateProviderApiV1ProvidersProviderIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>, TError,{providerId: string;data: LLMProviderUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProviderApiV1ProvidersProviderIdPut>>,
        TError,
        {providerId: string;data: LLMProviderUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateProviderApiV1ProvidersProviderIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete provider configuration. Fails if referenced by active agents.
 * @summary Delete provider
 */
export const deleteProviderApiV1ProvidersProviderIdDelete = (
    providerId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/providers/${providerId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteProviderApiV1ProvidersProviderIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>, TError,{providerId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>, TError,{providerId: string}, TContext> => {

const mutationKey = ['deleteProviderApiV1ProvidersProviderIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>, {providerId: string}> = (props) => {
          const {providerId} = props ?? {};

          return  deleteProviderApiV1ProvidersProviderIdDelete(providerId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProviderApiV1ProvidersProviderIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>>
    
    export type DeleteProviderApiV1ProvidersProviderIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete provider
 */
export const useDeleteProviderApiV1ProvidersProviderIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>, TError,{providerId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProviderApiV1ProvidersProviderIdDelete>>,
        TError,
        {providerId: string},
        TContext
      > => {

      const mutationOptions = getDeleteProviderApiV1ProvidersProviderIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Fetch available models from configured Ollama host for model selection during provider setup.
 * @summary List Ollama models
 */
export const listOllamaModelsApiV1ProvidersOllamaModelsGet = (
    params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<OllamaModelsResponse>(
      {url: `/api/v1/providers/ollama/models`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListOllamaModelsApiV1ProvidersOllamaModelsGetQueryKey = (params?: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams,) => {
    return [
    `/api/v1/providers/ollama/models`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListOllamaModelsApiV1ProvidersOllamaModelsGetQueryOptions = <TData = Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError = HTTPValidationError>(params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOllamaModelsApiV1ProvidersOllamaModelsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>> = ({ signal }) => listOllamaModelsApiV1ProvidersOllamaModelsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListOllamaModelsApiV1ProvidersOllamaModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>>
export type ListOllamaModelsApiV1ProvidersOllamaModelsGetQueryError = HTTPValidationError


export function useListOllamaModelsApiV1ProvidersOllamaModelsGet<TData = Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError = HTTPValidationError>(
 params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>,
          TError,
          Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListOllamaModelsApiV1ProvidersOllamaModelsGet<TData = Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError = HTTPValidationError>(
 params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>,
          TError,
          Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListOllamaModelsApiV1ProvidersOllamaModelsGet<TData = Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError = HTTPValidationError>(
 params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Ollama models
 */

export function useListOllamaModelsApiV1ProvidersOllamaModelsGet<TData = Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError = HTTPValidationError>(
 params: ListOllamaModelsApiV1ProvidersOllamaModelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOllamaModelsApiV1ProvidersOllamaModelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListOllamaModelsApiV1ProvidersOllamaModelsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



