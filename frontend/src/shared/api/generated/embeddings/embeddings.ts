/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Pulse Radar API
 * Feel the heartbeat of your projects
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  BatchEmbedAtomsRequest,
  BatchEmbedRequest,
  BatchEmbedResponse,
  EmbedRequest,
  EmbedResponse,
  HTTPValidationError
} from '../../model';

import { customInstance } from '../../../lib/api/mutator';




/**
 * Generate embeddings for multiple messages in background.

Queues background task to process messages in batches. Returns immediately
with task_id for tracking progress. Task handles errors gracefully and
tracks success/failed/skipped counts.

Args:
    request: Request containing message_ids and provider_id
    session: Database session (injected)

Returns:
    BatchEmbedResponse with task_id and message count

Raises:
    404: Provider not found
    400: Invalid request (empty message_ids list)

Example:
    ```
    POST / api / v1 / embeddings / messages / batch
    {"message_ids": [1, 2, 3, 4, 5], "provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```

    Response:
    ```
    {"task_id": "abc123...", "count": 5, "provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```
 * @summary Generate Batch Embeddings
 */
export const generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost = (
    batchEmbedRequest: BatchEmbedRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BatchEmbedResponse>(
      {url: `/api/v1/embeddings/messages/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchEmbedRequest, signal
    },
      );
    }
  


export const getGenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>, TError,{data: BatchEmbedRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>, TError,{data: BatchEmbedRequest}, TContext> => {

const mutationKey = ['generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>, {data: BatchEmbedRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>>
    export type GenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPostMutationBody = BatchEmbedRequest
    export type GenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPostMutationError = HTTPValidationError

    /**
 * @summary Generate Batch Embeddings
 */
export const useGenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>, TError,{data: BatchEmbedRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPost>>,
        TError,
        {data: BatchEmbedRequest},
        TContext
      > => {

      const mutationOptions = getGenerateBatchEmbeddingsApiV1EmbeddingsMessagesBatchPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate embeddings for multiple atoms in background.

Queues background task to process atoms in batches. Returns immediately
with task_id for tracking progress. Task handles errors gracefully and
tracks success/failed/skipped counts.

Args:
    request: Request containing atom_ids and provider_id
    session: Database session (injected)

Returns:
    BatchEmbedResponse with task_id and atom count

Raises:
    404: Provider not found
    400: Invalid request (empty atom_ids list)

Example:
    ```
    POST / api / v1 / embeddings / atoms / batch
    {"atom_ids": [1, 2, 3, 4, 5], "provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```

    Response:
    ```
    {"task_id": "def456...", "count": 5, "provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```
 * @summary Generate Batch Atom Embeddings
 */
export const generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost = (
    batchEmbedAtomsRequest: BatchEmbedAtomsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BatchEmbedResponse>(
      {url: `/api/v1/embeddings/atoms/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: batchEmbedAtomsRequest, signal
    },
      );
    }
  


export const getGenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>, TError,{data: BatchEmbedAtomsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>, TError,{data: BatchEmbedAtomsRequest}, TContext> => {

const mutationKey = ['generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>, {data: BatchEmbedAtomsRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>>
    export type GenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPostMutationBody = BatchEmbedAtomsRequest
    export type GenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPostMutationError = HTTPValidationError

    /**
 * @summary Generate Batch Atom Embeddings
 */
export const useGenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>, TError,{data: BatchEmbedAtomsRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPost>>,
        TError,
        {data: BatchEmbedAtomsRequest},
        TContext
      > => {

      const mutationOptions = getGenerateBatchAtomEmbeddingsApiV1EmbeddingsAtomsBatchPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate embedding for a single message.

Uses specified LLM provider to generate vector embedding for message content.
If message already has embedding, operation is skipped.

Args:
    message_id: ID of message to embed
    request: Request containing provider_id
    session: Database session (injected)

Returns:
    EmbedResponse with embedding status and length

Raises:
    404: Message or Provider not found
    400: Provider doesn't support embeddings
    500: Embedding generation failed

Example:
    ```
    POST / api / v1 / embeddings / messages / 123
    {"provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```
 * @summary Generate Message Embedding
 */
export const generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost = (
    messageId: string,
    embedRequest: EmbedRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EmbedResponse>(
      {url: `/api/v1/embeddings/messages/${messageId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: embedRequest, signal
    },
      );
    }
  


export const getGenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>, TError,{messageId: string;data: EmbedRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>, TError,{messageId: string;data: EmbedRequest}, TContext> => {

const mutationKey = ['generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>, {messageId: string;data: EmbedRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost(messageId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>>
    export type GenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPostMutationBody = EmbedRequest
    export type GenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPostMutationError = HTTPValidationError

    /**
 * @summary Generate Message Embedding
 */
export const useGenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>, TError,{messageId: string;data: EmbedRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPost>>,
        TError,
        {messageId: string;data: EmbedRequest},
        TContext
      > => {

      const mutationOptions = getGenerateMessageEmbeddingApiV1EmbeddingsMessagesMessageIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate embedding for a single atom.

Uses specified LLM provider to generate vector embedding for atom content
(combination of title and content). If atom already has embedding, operation is skipped.

Args:
    atom_id: ID of atom to embed
    request: Request containing provider_id
    session: Database session (injected)

Returns:
    EmbedResponse with embedding status and length

Raises:
    404: Atom or Provider not found
    400: Provider doesn't support embeddings
    500: Embedding generation failed

Example:
    ```
    POST / api / v1 / embeddings / atoms / 456
    {"provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```
 * @summary Generate Atom Embedding
 */
export const generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost = (
    atomId: string,
    embedRequest: EmbedRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EmbedResponse>(
      {url: `/api/v1/embeddings/atoms/${atomId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: embedRequest, signal
    },
      );
    }
  


export const getGenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>, TError,{atomId: string;data: EmbedRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>, TError,{atomId: string;data: EmbedRequest}, TContext> => {

const mutationKey = ['generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>, {atomId: string;data: EmbedRequest}> = (props) => {
          const {atomId,data} = props ?? {};

          return  generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost(atomId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>>
    export type GenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPostMutationBody = EmbedRequest
    export type GenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPostMutationError = HTTPValidationError

    /**
 * @summary Generate Atom Embedding
 */
export const useGenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>, TError,{atomId: string;data: EmbedRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPost>>,
        TError,
        {atomId: string;data: EmbedRequest},
        TContext
      > => {

      const mutationOptions = getGenerateAtomEmbeddingApiV1EmbeddingsAtomsAtomIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate embedding for a single topic.

Uses specified LLM provider to generate vector embedding for topic content
(combination of name and description). If topic already has embedding, operation is skipped.

Args:
    topic_id: ID of topic to embed
    request: Request containing provider_id
    session: Database session (injected)

Returns:
    EmbedResponse with embedding status and length

Raises:
    404: Topic or Provider not found
    400: Provider doesn't support embeddings
    500: Embedding generation failed

Example:
    ```
    POST / api / v1 / embeddings / topics / 550e8400-e29b-41d4-a716-446655440000
    {"provider_id": "550e8400-e29b-41d4-a716-446655440000"}
    ```
 * @summary Generate Topic Embedding
 */
export const generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost = (
    topicId: string,
    embedRequest: EmbedRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EmbedResponse>(
      {url: `/api/v1/embeddings/topics/${topicId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: embedRequest, signal
    },
      );
    }
  


export const getGenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>, TError,{topicId: string;data: EmbedRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>, TError,{topicId: string;data: EmbedRequest}, TContext> => {

const mutationKey = ['generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>, {topicId: string;data: EmbedRequest}> = (props) => {
          const {topicId,data} = props ?? {};

          return  generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost(topicId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>>
    export type GenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPostMutationBody = EmbedRequest
    export type GenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPostMutationError = HTTPValidationError

    /**
 * @summary Generate Topic Embedding
 */
export const useGenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>, TError,{topicId: string;data: EmbedRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPost>>,
        TError,
        {topicId: string;data: EmbedRequest},
        TContext
      > => {

      const mutationOptions = getGenerateTopicEmbeddingApiV1EmbeddingsTopicsTopicIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    