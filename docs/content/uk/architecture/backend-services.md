# Каталог Backend Сервісів

**Останнє Оновлення:** 26 жовтня 2025
**Загальна Кількість Сервісів:** 30
**Архітектурний Патерн:** Доменно-Орієнтований Шар Сервісів з Впровадженням Залежностей

---

## Зміст

1. [Огляд](#огляд)
2. [Патерн Архітектури Сервісів](#патерн-архітектури-сервісів)
3. [CRUD Сервіси](#crud-сервіси)
4. [LLM Сервіси](#llm-сервіси)
5. [Сервіси Аналізу](#сервіси-аналізу)
6. [Сервіси Векторної Бази Даних](#сервіси-векторної-бази-даних)
7. [Сервіси Знань](#сервіси-знань)
8. [Інфраструктурні Сервіси](#інфраструктурні-сервіси)
9. [Залежності Сервісів](#залежності-сервісів)

---

## Огляд

Backend реалізує 30 спеціалізованих сервісів, організованих у 7 доменних груп. Кожен сервіс слідує патернам async/await, використовує впровадження залежностей через FastAPI та підтримує єдину відповідальність.

### Розподіл Сервісів за Доменами

| Домен | Кількість | Призначення |
|--------|-------|---------|
| CRUD Сервіси | 10 | Операції бази даних для основних сутностей |
| LLM Сервіси | 4 | Оркестрація AI агентів та інтеграція LLM |
| Сервіси Аналізу | 3 | Аналіз повідомлень та генерація пропозицій завдань |
| Сервіси Векторної БД | 4 | Семантичний пошук та управління ембедінгами |
| Сервіси Знань | 2 | Вилучення знань та версіонування |
| Інфраструктурні Сервіси | 4 | Зовнішні інтеграції та системні утиліти |
| Утиліти Сервісів | 3 | Генерація схем, шифрування, валідація |

**Загалом:** 30 сервісів у 7 доменах

---

## Патерн Архітектури Сервісів

### Загальні Патерни

Всі сервіси слідують цим принципам дизайну:

1. **Async-First:** Усі I/O операції використовують `async/await`
2. **На Основі Сесій:** Доступ до бази даних через впровадження залежностей `AsyncSession`
3. **Типобезпечні:** Повні анотації типів з mypy strict відповідністю
4. **Єдина Відповідальність:** Кожен сервіс обробляє одну доменну відповідальність
5. **На Основі Протоколів:** Сервіси реалізують абстрактні протоколи для тестованості

### Типова Структура Сервісу

Сервіси впроваджуються в FastAPI endpoints через `Depends()`:

- Конструктор приймає `AsyncSession` або об'єкти конфігурації
- Публічні методи повертають Pydantic моделі для валідації
- Обробка помилок використовує доменно-специфічні винятки
- Логування через стандартний Python модуль `logging`

---

## CRUD Сервіси

Базові операції створення, читання, оновлення, видалення для сутностей бази даних.

### Користувач і Ідентифікація

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `UserService` | Управління користувачами та зв'язування Telegram профілів | `identify_or_create_user()`, `get_or_create_source()` |

### Комунікація

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `MessageCRUD` | Message CRUD з фільтрацією та класифікацією | Створення, читання, оновлення, видалення, список з фільтрами |

### Управління Знаннями

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `TopicCRUD` | Управління топіками з автовибором іконок | CRUD операції, `auto_select_icon()`, `auto_select_color()` |
| `AtomCRUD` | Операції з атомами та управління зв'язками | CRUD, створення зв'язків, управління зв'язками топік-атом |

### Завдання

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `TaskCRUD` | Операції застарілої системи завдань | CRUD для сутностей Task |

### Конфігурація LLM

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `ProviderCRUD` | Управління LLM провайдерами з шифруванням API ключів | CRUD, валідація провайдера, шифрування/розшифрування API ключів |
| `AgentCRUD` | Управління конфігурацією агентів | CRUD для сутностей AgentConfig |
| `AssignmentCRUD` | Відстеження призначень агент-завдання | CRUD для AgentTaskAssignment |

### Конфігурація Аналізу

| Сервіс | Відповідальність | Ключові Операції |
|---------|---------------|----------------|
| `ProjectService` | Управління конфігурацією проєкту | CRUD для ProjectConfig з версіонуванням |
| `ProposalService` | CRUD пропозицій завдань та процес рецензування | CRUD, дії рецензування, пакетні операції |

**Загалом CRUD Сервісів:** 10 сервісів

---

## LLM Сервіси

Шар інтеграції AI, що надає структуровані LLM взаємодії та оркестрацію агентів.

| Сервіс | Відповідальність | Залежності |
|---------|---------------|--------------|
| `AgentRegistry` | Управління життєвим циклом runtime інстансів агентів | Немає (singleton патерн) |
| `AgentTestService` | Тестування конфігурацій агентів з кастомними промптами | Pydantic-AI, CredentialEncryption |
| `OllamaService` | Інтеграція провайдера Ollama та лістинг моделей | HTTP клієнт для Ollama API |
| `LLMProposalService` | Генерація пропозицій завдань з пакетів повідомлень використовуючи LLM | AgentConfig, LLMProvider, RAGContextBuilder |

### AgentRegistry

Центральний реєстр для runtime інстансів агентів. Управляє створенням агентів, кешуванням та очищенням.

- **Патерн:** Singleton з in-memory сховищем
- **Операції:** `register_agent()`, `get_agent()`, `unregister_agent()`, `list_agents()`, `clear()`
- **Випадок Використання:** Повторне використання налаштованих агентів між запитами без пересоздання

### AgentTestService

Валідує конфігурації агентів шляхом виконання тестових промптів проти LLM провайдерів.

- **Патерн:** Stateless сервіс з залежністю від сесії
- **Операції:** `test_agent(agent_id, test_prompt)` → TestAgentResponse
- **Випадок Використання:** Валідація конфігурації перед розгортанням у продакшн

### OllamaService

Інтеграція з локальним LLM провайдером Ollama.

- **Патерн:** Stateless HTTP клієнт обгортка
- **Операції:** `list_models()`, `validate_connection()`
- **Випадок Використання:** Виявлення моделей Ollama та перевірка здоров'я

### LLMProposalService

Основний AI сервіс для генерації пропозицій завдань з пакетів повідомлень.

- **Патерн:** Stateful сервіс з конфігурацією агента
- **Операції:** `generate_proposals(messages, project_config)`, `generate_proposals_with_rag()`
- **Випадок Використання:** Виконання аналізу з RAG-покращеним контекстом

**Загалом LLM Сервісів:** 4 сервіси

---

## Сервіси Аналізу

Аналіз повідомлень, фільтрація шуму та оркестрація генерації пропозицій завдань.

| Сервіс | Відповідальність | Алгоритм |
|---------|---------------|-----------|
| `AnalysisExecutor` | Оркестрація життєвого циклу виконання аналізу | 9-кроковий конвеєр виконання |
| `ImportanceScorer` | Фільтрація шуму повідомлень через евристичну оцінку | 4-факторний зважений алгоритм |
| `TopicClassificationService` | Експерименти класифікації топіків з метриками | LLM-базована класифікація з матрицею плутанини |

### AnalysisExecutor

Оркеструє повний робочий процес виконання аналізу від отримання повідомлень до генерації пропозицій.

**Конвеєр Виконання (9 Кроків):**

1. `start_run()` - Оновити статус до "running"
2. `fetch_messages()` - Запит повідомлень у часовому вікні
3. `prefilter_messages()` - Фільтр за ключовими словами, довжиною, @згадками
4. `create_batches()` - Групування повідомлень у 5-10 хвилинні вікна
5. `process_batch()` - Виклик LLM, парсинг пропозицій
6. `save_proposals()` - Зберігання пропозицій, оновлення лічильників
7. `update_progress()` - Трансляція WebSocket подій прогресу
8. `complete_run()` - Встановити статус "completed"
9. `fail_run()` - Обробка помилок, зберігання логів помилок

**Функції:**
- Підтримка RAG для контекстно-обізнаних пропозицій
- Оновлення прогресу в реальному часі через WebSocket
- Налаштовувані часові вікна та контексти проєктів
- Оптимізація розміру пакета (макс 50 повідомлень/пакет)

### ImportanceScorer

Класифікує повідомлення як noise/weak_signal/signal використовуючи 4-факторний евристичний алгоритм.

**Фактори Оцінки (Зважені):**

| Фактор | Вага | Правила Оцінки |
|--------|--------|---------------|
| Вміст | 40% | Довжина, ключові слова, питання, URL, блоки коду |
| Автор | 20% | Історична оцінка якості повідомлень |
| Темпоральні | 20% | Свіжість повідомлення, активність топіка |
| Топіки | 20% | Важливість топіка (кількість повідомлень) |

**Пороги Класифікації:**
- `noise`: оцінка < 0.3 (наприклад, "lol", "+1", один емодзі)
- `weak_signal`: 0.3 ≤ оцінка ≤ 0.7 (наприклад, короткі питання)
- `signal`: оцінка > 0.7 (наприклад, звіти про баги, запити функцій)

**Продуктивність:** Обробляє 100 повідомлень за 1-2 секунди (без LLM)

### TopicClassificationService

Експериментує з класифікацією топіків використовуючи різні LLM моделі та конфігурації.

**Можливості:**
- Тестування мульти-моделей (OpenAI, Ollama, кастомні)
- Розрахунок метрик точності
- Генерація матриці плутанини
- Зберігання результатів класифікації для аналізу

**Випадок Використання:** Вибір моделі та оптимізація промптів перед розгортанням у продакшн

**Загалом Сервісів Аналізу:** 3 сервіси

---

## Сервіси Векторної Бази Даних

Семантичний пошук та управління ембедінгами використовуючи pgvector та косинусну подібність.

| Сервіс | Відповідальність | Векторні Операції |
|---------|---------------|-------------------|
| `EmbeddingService` | Генерація ембедінгів для повідомлень та атомів | Пакетні ембедінги, одиночні ембедінги |
| `SemanticSearchService` | Пошук подібності на основі векторів | Пошук повідомлень/атомів, пошук дублікатів |
| `RAGContextBuilder` | Складання RAG контексту з подібних повідомлень/атомів | Побудова контексту для LLM промптів |
| `VectorQueryBuilder` | Конструювання pgvector SQL запитів | Допоміжні генератори запитів |

### EmbeddingService

Генерує векторні ембедінги використовуючи налаштований LLM провайдер.

**Операції:**
- `generate_embedding(text)` → `list[float]` (одиночний)
- `embed_messages_batch(messages)` → масове оновлення бази даних
- `embed_atoms_batch(atoms)` → масове оновлення бази даних

**Підтримувані Провайдери:** OpenAI, Ollama (через text-embedding-ada-002 або локальні моделі)

### SemanticSearchService

Виконує семантичний пошук подібності використовуючи pgvector оператор косинусної відстані `<=>`.

**Методи Пошуку:**

| Метод | Призначення | Поріг |
|--------|---------|-----------|
| `search_messages(query)` | Текстовий пошук | 0.7 (налаштовуваний) |
| `find_similar_messages(message_id)` | Виявлення подібних повідомлень | 0.7 (налаштовуваний) |
| `find_duplicates(message_id)` | Виявлення дублікатів | 0.95 (висока подібність) |
| `search_atoms(query)` | Семантичний пошук атомів | 0.7 (налаштовуваний) |
| `find_similar_atoms(atom_id)` | Виявлення пов'язаних атомів | 0.7 (налаштовуваний) |

**Оцінка Подібності:** `similarity = 1 - (cosine_distance / 2)` (мапується до діапазону 0.0-1.0)

### RAGContextBuilder

Будує контекст для LLM промптів шляхом отримання семантично подібних повідомлень та атомів.

**Стратегія:** Ембед запиту → пошук top-k подібних елементів → форматування як рядок контексту

**Випадок Використання:** Покращена генерація пропозицій завдань з релевантним історичним контекстом

### VectorQueryBuilder

Допоміжний сервіс для конструювання pgvector SQL запитів з правильним приведенням типів.

**Призначення:** Спрощує конструкцію сирого SQL для складних векторних операцій

**Загалом Сервісів Векторної БД:** 4 сервіси

---

## Сервіси Знань

LLM-керована екстракція знань та відстеження версій для Топіків та Атомів.

| Сервіс | Відповідальність | Інтеграція LLM |
|---------|---------------|-----------------|
| `KnowledgeExtractionService` | Вилучення Топіків та Атомів з пакетів повідомлень | Pydantic-AI з структурованим виводом |
| `VersioningService` | Відстеження версій та процес затвердження | Версіонування бази даних |

### KnowledgeExtractionService

Аналізує пакети повідомлень для вилучення структурованих знань використовуючи LLM.

**Конвеєр Екстракції:**

1. `extract_knowledge(messages)` → Структурований вивід LLM
   - Топіки: Теми обговорення (2-4 слова)
   - Атоми: Атомарні одиниці знань (problem/solution/insight/decision/question/pattern/requirement)
   - Оцінки впевненості для фільтрації автостворення

2. `save_topics(extracted_topics, confidence_threshold=0.7)`
   - Створює нові топіки або знімки версій для існуючих
   - Автовибір іконок та кольорів

3. `save_atoms(extracted_atoms, topic_map, confidence_threshold=0.7)`
   - Створює атоми з зв'язками топіків
   - Відстеження версій для оновлень

4. `link_atoms(extracted_atoms, saved_atoms)`
   - Створює двонаправлені зв'язки атомів
   - Типи зв'язків: solves/supports/contradicts/continues/refines/relates_to/depends_on

5. `update_messages(messages, topic_map, extracted_topics)`
   - Призначає повідомлення до вилучених топіків

**Конфігурація LLM:**
- Системний промпт: Строге примусове виконання JSON схеми
- Повторні спроби виводу: 5 спроб для валідації
- Структурований вивід: Pydantic моделі з типобезпекою

**Фільтрація Впевненості:**
- Поріг за замовчуванням: 0.7 (70% впевненості)
- Елементи з низькою впевненістю пропускаються від автостворення
- Необхідний ручний перегляд для затвердження

### VersioningService

Відстежує зміни Топіків та Атомів з процесом затвердження.

**Життєвий Цикл Версії:**

1. `create_topic_version(topic_id, data, created_by)` → TopicVersion
2. `create_atom_version(atom_id, data, created_by)` → AtomVersion
3. `approve_version(version_id)` → Застосувати зміни до батьківської сутності
4. `get_version_history(entity_id)` → Список версій
5. `diff_versions(v1, v2)` → Порівняння змін

**Випадок Використання:** Людський перегляд LLM-генерованих знань перед інтеграцією у продакшн

**Загалом Сервісів Знань:** 2 сервіси

---

## Інфраструктурні Сервіси

Зовнішні інтеграції та утиліти системного рівня.

| Сервіс | Відповідальність | Зовнішня Система |
|---------|---------------|-----------------|
| `TelegramClientService` | Інтеграція Telegram Bot API | Telegram HTTP API |
| `TelegramIngestionService` | Пакетна інгестія повідомлень з Telegram чатів | Telegram API + MessageIngestionJob |
| `WebSocketManager` | Трансляція подій в реальному часі | Протокол WebSocket |
| `CredentialEncryption` | Fernet шифрування для API ключів | Бібліотека Cryptography |

### TelegramClientService

Обгортка Telegram Bot API для вихідних операцій.

**Операції:**
- `send_message(chat_id, text)` - Надіслати повідомлення користувачу Telegram
- `get_user_info(user_id)` - Отримати профіль користувача
- Управління вебхуками (встановлення, видалення, отримання інфо)

**Випадок Використання:** Відповіді бота, сповіщення користувачів, конфігурація вебхука

### TelegramIngestionService

Пакетна інгестія історичних повідомлень з Telegram чатів.

**Процес:**
1. Створити запис `MessageIngestionJob`
2. Отримати історію чату через Telegram API
3. Зберегти повідомлення з атрибуцією джерела
4. Оновити прогрес завдання в реальному часі
5. Транслювати WebSocket події для оновлень UI

**Випадок Використання:** Початкове наповнення даних, заповнення відсутніх повідомлень

### WebSocketManager

Централізований сервіс підключення WebSocket та трансляції подій.

**Типи Подій:**
- Прогрес виконання аналізу
- Оновлення інгестії повідомлень
- Сповіщення створення пропозицій
- Події розрахунку оцінки
- Статус вилучення знань

**Патерн:** Singleton з управлінням пулом підключень

**Операції:**
- `connect(websocket)` - Зареєструвати WebSocket підключення
- `disconnect(websocket)` - Очистити підключення
- `broadcast(channel, data)` - Надіслати подію всім підключеним клієнтам
- `get_connection_count()` - Моніторинг активних підключень

### CredentialEncryption

Fernet симетричне шифрування для чутливих API ключів.

**Операції:**
- `encrypt(plaintext)` → Base64-закодований зашифрований текст
- `decrypt(ciphertext)` → Оригінальний відкритий текст

**Безпека:**
- Деривація ключа з змінної оточення
- База даних зберігає лише зашифровані значення
- Розшифрування лише в пам'яті під час API викликів

**Загалом Інфраструктурних Сервісів:** 4 сервіси

---

## Утиліти Сервісів

Міжфункціональні відповідальності та допоміжний функціонал.

| Сервіс | Відповідальність |
|---------|---------------|
| `SchemaGenerator` | Генерація JSON схеми з Pydantic моделей |
| `ProviderValidator` | Валідація підключення LLM провайдера |

### SchemaGenerator

Генерує JSON схеми з Pydantic моделей для визначень відповідей TaskConfig.

**Випадок Використання:** Динамічне створення схем завдань для структурованих LLM виводів

### ProviderValidator

Валідує підключення LLM провайдера та автентифікацію.

**Валідації:**
- Ollama: HTTP тест підключення, лістинг моделей
- OpenAI: Верифікація API ключа, перевірка доступу до моделі

**Випадок Використання:** Валідація конфігурації провайдера перед створенням агента

**Загалом Утиліт Сервісів:** 3 сервіси (включає CredentialEncryption з Інфраструктури)

---

## Залежності Сервісів

### Міжсервісні Залежності

**Граф Залежностей Високого Рівня:**

```
LLMProposalService
    ├─► AgentConfig (конфігурація)
    ├─► LLMProvider (налаштування провайдера)
    └─► RAGContextBuilder (опціональний контекст)
        ├─► EmbeddingService (векторизація запиту)
        └─► SemanticSearchService (пошук подібності)

AnalysisExecutor
    ├─► AgentTaskAssignment (вибір агента)
    ├─► ProjectConfig (правила фільтрації)
    ├─► LLMProposalService (генерація пропозицій)
    └─► WebSocketManager (трансляція прогресу)

KnowledgeExtractionService
    ├─► AgentConfig (конфігурація екстракції)
    ├─► LLMProvider (доступ до LLM)
    ├─► VersioningService (відстеження змін)
    └─► TopicCRUD, AtomCRUD (персистентність сутностей)

ImportanceScorer
    ├─► MessageCRUD (пошук історії автора)
    └─► TopicCRUD (метрики активності топіка)
```

### Загальні Залежності

Усі сервіси залежать від:

- **AsyncSession:** Доступ до бази даних через SQLAlchemy
- **Logging:** Стандартна бібліотека Python logger
- **Pydantic:** Валідація запиту/відповіді

---

## Посібник Вибору Сервісу

### Коли Використовувати Кожен Сервіс

**Операції з Даними:**
- Потрібен message CRUD? → `MessageCRUD`
- Потрібне управління топіками? → `TopicCRUD`
- Потрібні операції з атомами? → `AtomCRUD`

**AI Операції:**
- Потрібні пропозиції завдань? → `LLMProposalService`
- Тестувати конфіг агента? → `AgentTestService`
- Вилучити знання? → `KnowledgeExtractionService`
- Фільтрувати шум? → `ImportanceScorer`

**Операції Пошуку:**
- Текстовий пошук? → `SemanticSearchService.search_messages()`
- Знайти дублікати? → `SemanticSearchService.find_duplicates()`
- Потрібні ембедінги? → `EmbeddingService`
- RAG контекст? → `RAGContextBuilder`

**Оркестрація:**
- Запустити аналіз? → `AnalysisExecutor`
- Експериментувати з моделями? → `TopicClassificationService`

**Зовнішні Інтеграції:**
- Надіслати Telegram повідомлення? → `TelegramClientService`
- Інгестувати історію чату? → `TelegramIngestionService`
- Транслювати події? → `WebSocketManager`

---

## Характеристики Продуктивності Сервісів

### Високопродуктивні Сервіси

Ці сервіси оптимізовані для швидкості та можуть обробляти високу пропускну здатність:

- `MessageCRUD`: <50мс CRUD операції
- `ImportanceScorer`: 1-2 секунди для 100 повідомлень
- `SemanticSearchService`: <200мс векторні пошуки
- `WebSocketManager`: Доставка подій в реальному часі

### Ресурсоємні Сервіси

Ці сервіси вимагають обережного управління ресурсами:

- `LLMProposalService`: Залежить від латентності LLM провайдера
- `EmbeddingService`: Рекомендовані пакетні операції (50+ елементів)
- `KnowledgeExtractionService`: LLM-залежний (5-30 секунд/пакет)
- `AnalysisExecutor`: Довготривалий (хвилини для повних виконань)

### Стратегії Кешування

- `AgentRegistry`: In-memory кешування інстансів агентів
- `SemanticSearchService`: Покладається на індекси векторів бази даних
- `ProviderCRUD`: Без кешування (зміни конфігурації потребують негайного ефекту)

---

## Пов'язана Документація

- **Моделі Бази Даних:** Дивіться `database-models.md`
- **Архітектура LLM:** Дивіться `llm-architecture.md`
- **Фонові Завдання:** Дивіться `background-tasks.md`
- **API Endpoints:** Дивіться директорію backend/app/api/v1/
- **Керівництва Проєкту:** Дивіться CLAUDE.md

---

*Цей документ каталогізує всі 30 backend сервісів, організовані за доменами. Для деталей реалізації зверніться до вихідного коду сервісів у `backend/app/services/`.*
